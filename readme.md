# '실전! querydsl' 강의에 대해 공부한 자료입니다.

 --------

## 이해한 내용 정리
### Querydsl
- jpa로 복잡한 쿼리와 동적 쿼리 작성할때 겪는 어려움을 해결해주는 아이
- 쿼리를 자바코드로 작성할 수 있어서 컴파일 시점에 에러잡기 가능
### Querydsl 구성 요소 
  - Q 클래스
    - 정적 필드
    - 컴파일 시점에 Q클래스 확인하므로써 컴파일 시점에 에러잡기가 가능하도록 함 
  - `JpaQueryFactory`
    - querydsl을 실제 sql로 변환하여 실행하도록 도와주는 아이
### 동적 쿼리 Builder
- querydsl에서 논리 조건을 동적으로 생성하기 위한 빌더
- or, and, not 이용해 여러 조건 복합 쿼리 생성
### 동적 쿼리 where 파라미터
- dto의 생성자에 `@QueryProjection` 추가해 Q클래스 생성 후, 조건에 대한 메소드 생성하고 where 절 파라미터로 넣기
- 동적 쿼리 만들 때 페이징 쿼리도 넣자
### 사용자 정의 리포지토리
- 스프링 데이터 jpa와 Querydsl을 같이 사용할 때, 스프링 데이터 jpa가 간단한 쿼리를 기본 제공해주는 도구라면, 사용자 정의 리포지토리는 복잡한 쿼리가 필요할 때 querydsl로 작성한 코드를 넣어놓는 장소
- 사용자 정의 인터페이스를 생성 후 구현하고, 스프링 데이터 레포지토리에 사용자 정의 인터페이스를 상속하는 방식
### 카운트 조회 방식
- 데이터와 카운트를 한번에 조회하는 방식은 데이터가 많을 경우, 성능상의 문제 때문에 데이터와 카운트를 따로 조회하는 방식이 권장된다.
- Querydsl에서 `fetchResults()`와 `fetchCount()`는 향후 미지원될 예정이므로 그 대신 `fetch()`와 `fetch().size()` 사용이 권장된다.
- count 쿼리가 생략 가능할 경우 생략하는 것도 성능 최적화 측면에서 좋다.
## 깨달은 내용
복잡한 쿼리와 동적 쿼리에 대한 jpa의 한계를 극복하기 위한 방법으로 Querydsl에 대해 공부하는 시간을 가졌다. querydsl은 컴파일 시점에 에러를 잡아줘서 동적 쿼리 이외에도 쿼리 작성에 이점을 가지는 것 같다. sql에서 지원하는 문법과 jpql에서 지원하는 문법 간의 미묘한 차이가 있고, querydsl은 대체로 jpql을 따르고 있긴하나 jpql에 업데이트된 변경사항이 querydsl에 아직 적용되지 않은 것들이 있어서 이에 대한 내용을 비교해 정리해놓으면 좋을 것 같다는 생각이 든다.